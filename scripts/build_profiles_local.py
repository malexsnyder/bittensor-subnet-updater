#!/usr/bin/env python3
"""
Bittensor Subnet Profile Builder

This script reads subnet data from data/subnets.json (generated by fetch_subnets_bt.py)
and creates Markdown profiles for each subnet with placeholders for future enhancement.
"""

import json
import re
import time
from pathlib import Path
from typing import Dict, Any, List

# File paths
SUBNETS_JSON = Path("data/subnets.json")
OUT_DIR = Path("data/profiles")
OUT_DIR.mkdir(parents=True, exist_ok=True)

def slug(text: str) -> str:
    """Convert text to URL-friendly slug."""
    return re.sub(r'[^a-z0-9]+', '-', text.lower()).strip('-')

def format_number(value: Any) -> str:
    """Format numbers for display."""
    if value is None:
        return "N/A"
    try:
        if isinstance(value, (int, float)):
            if value >= 1000000:
                return f"{value/1000000:.1f}M"
            elif value >= 1000:
                return f"{value/1000:.1f}K"
            else:
                return str(value)
        return str(value)
    except:
        return str(value)

def get_subnet_status(subnet: Dict[str, Any]) -> str:
    """Determine subnet status based on available data."""
    if "error" in subnet:
        return "âŒ Error fetching data"
    
    validator_count = subnet.get("validator_count", 0)
    miner_count = subnet.get("miner_count", 0)
    
    if validator_count == 0 and miner_count == 0:
        return "âš ï¸ No validators/miners"
    elif validator_count > 0 and miner_count > 0:
        return "âœ… Active"
    else:
        return "ðŸ”„ Partial"

def create_subnet_profile(subnet: Dict[str, Any]) -> str:
    """Create a Markdown profile for a subnet."""
    subnet_id = subnet.get("id", "Unknown")
    name = subnet.get("name", f"Subnet {subnet_id}")
    
    # Determine status based on available data
    if "error" in subnet:
        status = "âŒ Error fetching data"
    elif subnet.get("is_active") is False:
        status = "âš ï¸ Inactive"
    elif subnet.get("is_active") is True:
        status = "âœ… Active"
    else:
        status = "ðŸ”„ Status unknown"
    
    # Extract key metrics from the actual data structure
    price = subnet.get("price", 0)
    owner_hotkey = subnet.get("owner_hotkey", "Unknown")
    exists = subnet.get("exists", False)
    hyperparameters = subnet.get("hyperparameters", {})
    
    # Format hyperparameters if available
    hyperparams_text = ""
    if hyperparameters:
        hyperparams_text = "\n".join([f"- **{k}:** {v}" for k, v in hyperparameters.items()])
    
    template = f"""# {name} (Subnet {subnet_id})

**Status:** {status}

## Overview
**Primary Function:** *[To be filled by AI agent]*

**Problem It Solves:** *[To be filled by AI agent]*

**Target Audience:** 
- *[To be filled by AI agent]*
- *[To be filled by AI agent]*

## Blockchain Metrics
- **Subnet ID:** {subnet_id}
- **Exists:** {exists}
- **Active:** {subnet.get("is_active", "Unknown")}
- **Owner Hotkey:** `{owner_hotkey}`
- **Price:** {format_number(price)} TAO

## Hyperparameters
{hyperparams_text if hyperparams_text else "- No hyperparameters available"}

## Error Information
{format_error_info(subnet)}

## Analysis Placeholders
**Projected Growth Score (1â€“10):** *[To be filled by AI agent]*

**Conviction Scores**
- **Short-term (1â€“3 mo):** *[To be filled by AI agent]*
- **Medium-term (3â€“12 mo):** *[To be filled by AI agent]*
- **Long-term (1+ yr):** *[To be filled by AI agent]*

**Buy/Sell Conviction Meter:** *[To be filled by AI agent]*

**Trending / Alerts (last 48h):** *[To be filled by AI agent]*

**Official Link:** *[To be filled by AI agent]*

---
*Profile generated from Bittensor blockchain data on {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(subnet.get("last_update", 0)))}*
*Source: Bittensor Subtensor SDK (Finney network) - Public data only*
"""
    
    return template

def format_error_info(subnet: Dict[str, Any]) -> str:
    """Format error information for display."""
    errors = []
    for key, value in subnet.items():
        if key.endswith("_error") and value:
            errors.append(f"- **{key.replace('_error', '')}:** {value}")
    
    if errors:
        return "\n".join(errors)
    else:
        return "- No errors reported"

def main():
    """Main function to generate profiles for all subnets."""
    print("Reading subnet data...")
    
    if not SUBNETS_JSON.exists():
        print(f"Error: {SUBNETS_JSON} not found!")
        print("Please run 'python scripts/fetch_subnets_bt.py' first to fetch subnet data.")
        return
    
    try:
        # Load subnet data
        with open(SUBNETS_JSON, 'r') as f:
            data = json.load(f)
        
        subnets = data.get("subnets", [])
        if not subnets:
            print("No subnet data found in the JSON file.")
            return
        
        print(f"Found {len(subnets)} subnets to process...")
        
        # Generate profiles for each subnet
        profiles_created = 0
        for i, subnet in enumerate(subnets, 1):
            subnet_id = subnet.get("id", f"unknown_{i}")
            name = subnet.get("name", f"Subnet {subnet_id}")
            
            print(f"Creating profile for {name} ({i}/{len(subnets)})...")
            
            # Generate profile content
            profile_content = create_subnet_profile(subnet)
            
            # Create filename
            filename = f"{subnet_id}_{slug(name)}.md"
            output_path = OUT_DIR / filename
            
            # Write profile to file
            output_path.write_text(profile_content)
            profiles_created += 1
        
        print(f"\nSuccessfully created {profiles_created} subnet profiles!")
        print(f"Profiles saved to: {OUT_DIR}")
        
        # Print summary
        print("\nSummary:")
        print(f"- Profiles created: {profiles_created}")
        print(f"- Output directory: {OUT_DIR}")
        print(f"- Source data: {SUBNETS_JSON}")
        
        # List created files
        print("\nCreated files:")
        for profile_file in sorted(OUT_DIR.glob("*.md")):
            print(f"  - {profile_file.name}")
            
    except json.JSONDecodeError as e:
        print(f"Error parsing JSON file: {e}")
    except Exception as e:
        print(f"Error processing subnet data: {e}")

if __name__ == "__main__":
    main()
